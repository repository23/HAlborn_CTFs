// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;

import {DeployToken} from "../script/DeployToken.s.sol";
import {UpgradeToken} from "../script/UpgradeToken.s.sol";
import {Test, console} from "forge-std/Test.sol";
import {StdCheats} from "forge-std/StdCheats.sol";
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";



import {HalbornToken} from "../src/HalbornToken_flattened.sol";
import {HalbornTokenV2} from "../src/HalbornToken_flattened_v2.sol";


import {HalbornNFT, HalbornNFTv2} from "../src/HalbornNFT_flattened.sol";

contract DeployAndUpgradeTokenTest is StdCheats, Test {
    DeployToken public deployToken;
    UpgradeToken public upgradeToken;
    address public OWNER = address(1);

    function setUp() public {
        deployToken = new DeployToken();
        upgradeToken = new UpgradeToken();

    }

    function testTokenWorks() public {
        address proxyAddress = deployToken.deployToken(); // in first deploy we also deploy 1967 proxy and token, and change return address in this function to 
        // proxy address in the same function.
        uint256 expectedValue = 1;
        assertEq(expectedValue, HalbornToken(proxyAddress).version());
    }

   /* function testDeploymentIsV1() public {
        address proxyAddress = deployBox.deployBox();
        uint256 expectedValue = 7;
        vm.expectRevert();
        BoxV2(proxyAddress).mint(expectedValue);
    }
*/
    function testUpgradeWorks() public {
        address proxyAddress = deployToken.deployToken(); 

        HalbornTokenV2 halborn2 = new HalbornTokenV2();
        UpgradeToken upgradeToken = new UpgradeToken();

        vm.prank(HalbornToken(proxyAddress).owner());
        HalbornToken(proxyAddress).transferOwnership(msg.sender);

        address proxy = upgradeToken.upgradeToken(proxyAddress, address(halborn2));

        uint256 expectedValue = 2;
        assertEq(expectedValue, HalbornTokenV2(proxy).version());


    }




}
