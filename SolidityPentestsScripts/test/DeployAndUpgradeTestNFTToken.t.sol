// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;


import {UpgradeToken} from "../script/UpgradeToken.s.sol";
import {Test, console} from "forge-std/Test.sol";
import {StdCheats} from "forge-std/StdCheats.sol";
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";


import {HalbornToken} from "../src/HalbornToken_flattened.sol";
import {HalbornTokenV2} from "../src/HalbornToken_flattened_v2.sol";


import {HalbornNFT, HalbornNFTv2} from "../src/HalbornNFT_flattened.sol";
import {DeployNFTToken} from "../script/DeployNFT.s.sol";

contract DeployAndUpgradeNFTTokenTests is StdCheats, Test {
    DeployNFTToken public deployNFT;
    UpgradeToken public upgradeToken;
    address public OWNER = address(1);

    function setUp() public {
        deployNFT = new DeployNFTToken();
        upgradeToken = new UpgradeToken();

    }

    function testNFTTokenWorks() public {
        address proxyAddress = deployNFT.deployNFTToken(); // in first deploy we also deploy 1967 proxy and token, and change return address in this function to 
        // proxy address in the same function.
        uint256 expectedValue = 1;
        assertEq(expectedValue, HalbornNFT(proxyAddress).version());
    }

   /* function testDeploymentIsV1() public {
        address proxyAddress = deployBox.deployBox();
        uint256 expectedValue = 7;
        vm.expectRevert();
        BoxV2(proxyAddress).mint(expectedValue);
    }
*/
    function testNFTUpgradeWorks() public {
        address proxyAddress = deployNFT.deployNFTToken(); 

        HalbornNFTv2 halborn2 = new HalbornNFTv2();
        upgradeToken = new UpgradeToken();

        vm.prank(HalbornNFT(proxyAddress).owner());
        HalbornNFT(proxyAddress).transferOwnership(msg.sender);

        address proxy = upgradeToken.upgradeNFTToken(proxyAddress, address(halborn2));

        uint256 expectedValue = 2;
        HalbornNFTv2(proxy).version2();
        assertEq(expectedValue, HalbornNFTv2(proxy).version());


    }

    function testNFTsetMerkleRootWorks() public {
        address proxyAddress = deployNFT.deployNFTToken(); // in first deploy we also deploy 1967 proxy and token, and change return address in this function to 
        // proxy address in the same function.
        bytes32 expectedValue = 0x9d997719c0a5b5f6db9b8ac69a988be57cf324cb9fffd51dc2c37544bb520d65;
        
        assertEq(expectedValue, HalbornNFT(proxyAddress).merkleRoot());
        bytes32 newValue = 0xda2a605bdf59a3b18e24cd0b2d9110b6ffa2340f6f67bc48214ac70e49d12770;

        HalbornNFT(proxyAddress).setMerkleRoot(newValue);
        assertEq(newValue, HalbornNFT(proxyAddress).merkleRoot());
    }




}
